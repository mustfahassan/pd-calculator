<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PD Measurement</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container">
        <h1>PD Measurement</h1>
        
        <div class="instructions-card">
            <h5 class="instructions-title">
                <span class="icon">‚ÑπÔ∏è</span>
                Instructions
            </h5>
            <ol>
                <li>Allow camera access when prompted</li>
                <li>Click "Start Measurement" to begin</li>
                <li>Position your face within the guide oval</li>
                <li>Look straight at the camera</li>
                <li>Keep your head level and still</li>
                <li>Hold still during the countdown</li>
            </ol>
        </div>

        <div class="video-container">
            <!-- Note: removed initial video feed source -->
            <img id="videoFeed" style="display: none;" alt="Video feed">
            <div class="progress-bar" id="stabilityProgress"></div>
            <div class="status-overlay" id="statusMessage">Click Start Measurement to begin</div>
            <div class="countdown-overlay" id="countdownOverlay" style="display: none;">
                <span id="countdown">3</span>
            </div>
        </div>

        <div class="controls">
            <button class="start-btn" id="measureBtn">
                üì∑ Start Measurement
            </button>
            <button class="stop-btn" id="stopBtn" style="display: none;">
                ‚èπÔ∏è Stop
            </button>
        </div>

        <div class="results-card" id="resultsCard" style="display: none;">
            <div class="results-header">
                ‚úì Measurement Complete
            </div>
            
            <div class="results-grid">
                <div class="result-box">
                    <div class="result-title">
                        üëÅÔ∏è Pupillary Distance
                    </div>
                    <div class="measurement-value" id="pdValue">-- mm</div>
                </div>
                
                <div class="result-box">
                    <div class="result-title">
                        ‚ö° Measurement Quality
                    </div>
                    <div class="measurement-value success" id="confidenceValue">--%</div>
                    <div class="confidence">Confidence Score</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const measureBtn = document.getElementById('measureBtn');
        const stopBtn = document.getElementById('stopBtn');
        const videoFeed = document.getElementById('videoFeed');
        const countdownOverlay = document.getElementById('countdownOverlay');
        const countdownSpan = document.getElementById('countdown');
        const pdValue = document.getElementById('pdValue');
        const confidenceValue = document.getElementById('confidenceValue');
        const statusMessage = document.getElementById('statusMessage');
        const stabilityProgress = document.getElementById('stabilityProgress');
        const resultsCard = document.getElementById('resultsCard');

        let statusInterval;
        let mediaStream = null;

        async function requestCameraPermission() {
            try {
                // Request camera access first
                mediaStream = await navigator.mediaDevices.getUserMedia({ 
                    video: {
                        facingMode: "user",
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    } 
                });
                
                // If we got here, permission was granted
                return true;
            } catch (error) {
                console.error('Camera permission error:', error);
                statusMessage.textContent = "Camera access denied. Please allow camera access and try again.";
                return false;
            }
        }

        async function startMeasurement() {
            try {
                // First request camera permission explicitly
                const hasPermission = await requestCameraPermission();
                if (!hasPermission) {
                    statusMessage.textContent = "Camera permission is required. Please allow access and try again.";
                    return;
                }

                // Stop the media stream we used for permission
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                }

                // Now start the Flask camera feed
                const response = await fetch('/start_camera', { method: 'POST' });
                if (!response.ok) {
                    throw new Error('Failed to start camera');
                }

                videoFeed.src = "{{ url_for('pupil.video_feed') }}?" + new Date().getTime();
                videoFeed.style.display = 'block';
                stopBtn.style.display = 'block';
                measureBtn.style.display = 'none';
                statusInterval = setInterval(checkStatus, 100);
            } catch (error) {
                console.error('Error starting measurement:', error);
                statusMessage.textContent = "Error starting camera. Please try again.";
            }
        }

        async function checkStatus() {
            try {
                const response = await fetch('/get_status');
                const data = await response.json();
                
                const progressPercent = (data.stable_frames / data.threshold) * 100;
                stabilityProgress.style.width = `${progressPercent}%`;
                statusMessage.textContent = data.message;
                
                if (data.is_measuring) {
                    clearInterval(statusInterval);
                    await startCountdown();
                }
            } catch (error) {
                console.error('Error checking status:', error);
            }
        }

        async function startCountdown() {
            countdownOverlay.style.display = 'flex';
            let count = 3;
            
            return new Promise((resolve) => {
                const countdownTimer = setInterval(async () => {
                    countdownSpan.textContent = count;
                    count--;
                    
                    if (count < 0) {
                        clearInterval(countdownTimer);
                        countdownOverlay.style.display = 'none';
                        await getMeasurement();
                        resolve();
                    }
                }, 1000);
            });
        }

        async function getMeasurement() {
            try {
                const response = await fetch('/get_measurement');
                const data = await response.json();

                if (data.pd_mm) {
                    pdValue.textContent = `${Math.round(data.pd_mm)} mm`;
                    const qualityScore = Math.round(data.confidence);
                    confidenceValue.textContent = `${qualityScore}%`;

                    confidenceValue.className = 'measurement-value';
                    if (qualityScore >= 90) {
                        confidenceValue.classList.add('success');
                    } else if (qualityScore >= 75) {
                        confidenceValue.classList.add('good');
                    } else {
                        confidenceValue.classList.add('warning');
                    }

                    resultsCard.style.display = 'block';

                    await stopMeasurement();
                    measureBtn.textContent = 'üì∑ Measure Again';
                    measureBtn.style.display = 'block';
                } else {
                    handleMeasurementError("Measurement failed. Please try again.");
                }
            } catch (error) {
                console.error('Error getting measurement:', error);
                handleMeasurementError("Error getting measurement. Please try again.");
            }
        }

        async function stopMeasurement() {
            try {
                clearInterval(statusInterval);
                await fetch('/stop', { method: 'POST' });
                
                videoFeed.style.display = 'none';
                stopBtn.style.display = 'none';
                measureBtn.style.display = 'block';
                stabilityProgress.style.width = '0%';
                
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                    mediaStream = null;
                }
            } catch (error) {
                console.error('Stop error:', error);
            }
        }

        function handleMeasurementError(message) {
            pdValue.textContent = "-- mm";
            confidenceValue.textContent = "--%";
            statusMessage.textContent = message;
            statusMessage.style.display = 'block';
        }

        measureBtn.addEventListener('click', startMeasurement);
        stopBtn.addEventListener('click', stopMeasurement);
    </script>
</body>
</html>